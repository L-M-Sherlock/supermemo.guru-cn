# 我的个人助记媒介实现

原文：[My implementation of a personal mnemonic medium (andymatuschak.org)](https://notes.andymatuschak.org/z4mAF1uBV96r72e4NjLcDaujEyTPGiUQJEj8C)

我在自己的[笔记系统](https://notes.andymatuschak.org/z8XrKGDz49o6XxEx7tzGewzrXQnw6jSgv3Yyf)中实现了[记忆媒介可以扩展到个人的笔记](https://notes.andymatuschak.org/z5ARNXtS5VxteskEW91S1yYTgAcLABNXsZuJE)的想法。

这套系统的原理是，不断扫描一组 Markdown 文件，寻找其中所嵌入的卡片（卡片语法见下）。这些卡片便纳入我活跃的卡片集合中。我还实现了一个系统的组件，将这些提取出来的卡片同步到 Anki 中。

一些包含这个特点的样例笔记

- [人类作为信息处理者的渠道能力](https://notes.andymatuschak.org/z8iJEzmLdBMoWYtQHkDohDgeWz6UBGm74qEiW)

- [人类的通道容量随着每块比特的增加而增加](https://notes.andymatuschak.org/z6ZFtY8UGPaF9uofckBB7HwK62pssJAUg8C91)

为获取系统的实现，见https://github.com/andymatuschak/computer-supported-thinking。

对于正在进行的未处理的想法，见[个人记忆媒介](https://notes.andymatuschak.org/Log)

## 语法

### 创建典型的双面 SRS 卡片

> 问：一个量子比特的矢量空间有多少维？

> A. 两个。

问题和答案之间的空行是可选的。问题和答案目前不能跨越多个段落：包括Q.或A.的段落被提取为该领域。

### 创建挖空卡片

在散文笔记的背景下，我发现挖空往往更自然。这段话对应一张挖空卡片，其中有三个空。

> 一旦激活，服务工作者{执行一次性的启动计算}，然后过渡到{空闲}状态。从这个状态开始，它将处理{获取或消息事件}，直到最终终止。

挖空卡片会提取填空所在的整段文本。例如，这个两面的卡片相当于从前面的例子中提取的一张卡片。

> 问：一旦激活，服务工作者**? ??**，然后过渡到空闲状态。从这个状态开始，它将处理获取或消息事件，直到最终终止。

> 答：一旦激活，服务工作者*执行一次性的启动计算*，然后过渡到空闲状态。在这种状态下，它将处理获取或消息事件，直到最终终止。

### 异能性和特性

这个系统的目的是空闲地运作。也就是说：你可以随着时间的推移不断地修改你的笔记文件，它也会相应地跟踪变化。当你改变你的笔记时，系统会保持你所有嵌入的提示的SRS状态，除了你直接编辑过的提示。

更确切地说，嵌入的提示有*身份。你可以修改提示周围的注释，甚至把提示移到一个新的注释中，而你的审查历史将被保留下来。但是如果你修改了一个提示的文本，它将被视为一个新的提示，而你的回顾历史将不会从旧的提示中移植过来。这是因为这个系统是基于哑巴的纯文本文件，它没有足够的语义结构来明确说明一个给定的修改是代表一个新的提示还是一个旧的提示的修改。要解决这个问题，需要引入启发式方法或额外的识别标记。

双面提示的身份是由其问题和答案文本的哈希值得出的。Cloze提示的身份是由其包含段落的哈希值得出的。

虽然如果你在笔记文件之间移动提示语，系统会很高兴地跟踪它们，但如果相同的提示语出现在多个笔记文件中，其行为就无法定义。